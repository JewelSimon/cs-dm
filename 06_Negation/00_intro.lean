/-
* the connective, ¬ 
* the meaning of ¬ 
* proofs of inqualities,
* strategy: proof by negation
* strategy: modus tollens
* principle: non-contradiction
* negation elimination
* axiom: excluded middle
* double-negation elimination
* proof by contradiction
* proof by contrapositive 
-/

/-
In constructive logic, if we can 
construct a proof of a proposition,
P, then we can judge it to be true. 

What does it mean in constructive
logic for such a proposition, P, 
to be false?

The answer is that it means that it
would yield a contradiction were to 
be a proof of P. In other words, if
¬ P is true then it must be the case
that P → false. 

We express the claim that P is false 
by claiming that ¬ P is true, and this
is taken to mean just that P → false
is true, as there is a proof of it. 
The proposition ¬ P is defined to be
the proposition P → false. 

A proof of P → false, as with any 
proof of an implication, will be 
given as a function: one that 
takes a proof of P as an argument
and return a proof of false. As
there is no proof of false, such
an argument cannot exist. From 
the existence of the function we
conclude the non-existence of any
such proof. That is, ¬ P.

From now on, when working in 
constructive logic, when you see 
a proof of a proposition, ¬ P, it
is worthwhile viewing it as a value
of type P → false, which is to say
as a function taking proofs of P
and returning proofs of false.  
-/

/-
Check it: ¬ P is the same as P → false
-/
variable P : Prop
theorem same : (¬ P) = (P → false) := rfl


/-
In previous chapters we've worked with
many equality propositions. What about
inequality propositions? By x ≠ y, we
mean simply ¬ x = y. As an example, 
0 ≠ 1 is just different notation for
¬ 0 = 1. This in turn is 0 = 1 → false.
How can we prove such a proposition?
How can we prove 0 ≠ 1?
-/

/-
The short, fun, but unenlightening
answer is that Lean simply knows that
it is true. So write the proposition
and then write a period, and Lean
does the rest.
-/

theorem zneqo : 0 ≠ 1.

/-
We' now explain in a little more
detail what's going on. How does
"Lean know" there's a proof and
how to construct it? We present
the following elaborated proof.
-/

theorem zneqo' : ¬ 0 = 1 := 
    λ h : (0 = 1), 
        nat.no_confusion h

/-
As ¬ 0 = 1 is an implication,
our proof is a function: one 
that takes, h, a proof of 0 = 1,
and that build a proof of false
by applying nat.no_confusion to
that proof, h.

The key issue here is something
we haven't discussed yet. Values
of a single type can be built by
different "constructors" of that
type. In particular, 0 and 1 are 
built by different constructors.
 and values generated by
The key principle is that values
built by different constructors 
are by definition never equal in
Lean -- not for any type. 

Lean can thus tell immediately
that it's impossible for 0 = 1
because the terms 0 and 1 were 
built by different constructors. 


The nat.no_confusion function
is defined to return false if 
it could ever be given a proof 
of such an impossibility. Our 
proof of our theorem uses the
no_confusion rule/principle to 
show that from a proof of 0 = 1 
we can derive a proof of false.
Thus 0 = 1 → false, so ¬ 0 = 1.  

-/

/-
Here's a equivalent tactic script.
This example introduces the "assume,
show, from" proof pattern. Assume h
corresponds to h being an argument of
the function needed to prove ¬ 0 = 1.
The show false states what is to be
proved (the "return type"). And the 
from corresponds to the function body.  
-/
theorem zneqo'' : ¬ 0 = 1 := 
    begin
        assume h : (0 = 1),
        show false,
        from nat.no_confusion h
    end

/-
Note: In Lean, = binds more tightly (has 
a  higher precedence) than ¬. So ¬ 0 = 1 
means ¬ (0 = 1), not (¬ 0) = 1.
-/

/-
Proofs of inequalities for values of 
types other than nat can be produced 
using the no_confusion principles of
the respective other types. Here's a
proof that tt ≠ ff using the principle
for the bool type. 
-/

theorem ttneqff' : ¬ tt = ff := 
    begin
        assume h : (tt = ff),
        show false,
        from bool.no_confusion h
    end

/-
We're thankful we can use the period
(dot) notation here as well.
-/

theorem ttneqff : tt ≠ ff.

/-
EXERCISE: Is it true that 
"Hello, Lean!" ≠ "Hello Lean!"? 
Prove it. (How'd it do that?)

EXERCISE: What about 2 ≠ 1?
-/

/-
We've thus got our introduction rule for ¬.
To derive ¬ P, show that from an assumption
of (a proof of P) some kind of contraction
that cannot occur, and thus a proof of false,
would follow, leading to the conclusion that 
there must be no proof of P, that it isn't
true, and that ¬ P there is true.
-/

/-
What are some of the consequence of the
the understanding of negation that we've
developed so far?

Perhaps of the most important concept
at this point is that we have a strategy
for proving propositions of the form,
¬ P. We call it proof by negation. To 
use this strategy to prove ¬ P, we first
assume that we P is true (we have a proof) 
and we show this leads to a contradiction 
(we can build a proof of false). That then
justifies the conclusion that P is cannot
be true, thus ¬ P.

Negation introduction starts by assuming 
P, deriving a contradition, and concludind
¬ P. Here's the concept in the form of a 
trivial theorem. You'll have to give the
lambda expression a careful reading: it
says, "a function that takes a Prop, P, a
proof, p, of P, and that just returns p."
The same p works because a proof of P → 
false is a proof of ¬ P, by definition.
-/

theorem proof_by_negation : ∀ P : Prop,
    (P → false) → ¬ P :=
        λ P p, p

/-
A classic example of a proof by negation
is a proof that the square root of two is
irrational. You have to analyze the English
a little. This is really a proposition, P =
"the square root of two is NOT rational,
or ¬ (rational (sqrt 2)).

To prove it "by negation", assume that the 
square root of two IS rational. From that, 
derive a contradiction. From that, conclude
that the square root of two is not rational.
And now you have proved it is IRrational.
-/

/-
  **** Modus Tollens ****
-/

/-
Aristotle's reasoning
principle, modus tollens, allows one
to deduce ¬ Q → ¬ P from P → Q. Here's
an example: if you know that if it's
raining then the streets are wet then
you know if the streets are not wet,
then it must not be and is not raining.
-/

/-
We first validate this rule by writing it
as a function that takes a proof of P → Q
and then it takes a proof of ¬ Q, and from
it, it derives a proof of ¬ P. This shows
that (P → Q) → (¬ Q → ¬ P).
-/

theorem  modus_tollens' { P Q : Prop }
        (pfPtoQ : P → Q) (pfnQ : ¬ Q) : ¬ P:=
    λ (pfP : P), pfnQ (pfPtoQ pfP)

/-
We now present this same construction using
a lambda expression in order to make the whole
proposition, modus tollens explicit: for all propositions, P and Q, (P → Q) → (¬ Q → ¬ P).
-/

theorem modus_tollens: 
    ∀ P Q: Prop, (P → Q) → (¬ Q → ¬ P) :=
        λ P Q pfPQ pfnQ pfP, 
            pfnQ (pfPQ pfP)


/-
   **** Principle of non-contradiction ****
-/

theorem no_contra' { Q: Prop } (pf: Q ∧ ¬ Q) :
    false := 
        pf.2 pf.1

/-
We can also rewrite this to express the type,
i.e., the proposition, clearer
-/

theorem no_contra : ∀ Q: Prop, Q ∧ ¬ Q → false :=
    λ (Q : Prop) (pf : Q ∧ ¬ Q), 
        (and.elim_right pf) (and.elim_left pf)

#check no_contra


/-
     *** NEGATION ELIMINATION ***
    *** PROOF BY CONTRADICTION ***
-/

/-
What about negation elimination? Negation
elimination works in a closely related way.
Rather than deriving a contradiction from
a proof of P and concluding ¬ P, you show
that assuming ¬ P leads to a contraction,
thus to the conclusion that ¬ P is false,
there can be no proof it, thus ¬ ¬ P; and
then, by the principle of double negation
eliminaton one deduces that P must be true.

This is called proving P by contradiction.

Proof by contradiction is not accepted as
a valid principle in constructive logic,
because it relies on ¬ ¬ P → P. This issue
is that this rule is not constructive. To
see the problem, expand the ¬ signs into
their corresponding arrow notations. Then
¬ ¬ P, ¬ (¬ P), is ((P → false) → false).

What this says is that from a function 
that converts assumped proofs of P into
proofs of false, one can derive a proof
of false. So there can be no function of
this kind. But no where buried in any of
this is there an actual proof of P to be
found! There's simply no way to convert 
a function of type ((P → false) → false)
into a proof of P, so there is no proof
of ¬ ¬ P → P. That is, double negation 
elimination doesn't work in constructive
logic. Proofs by contradiction are thus
not available in Lean.

Lean can be extended by a single axiom, 
however, to make it classical, rather
than constructive. One simple asserts
the law of the excluded middle.

P : Prop
--------
P ∨ ¬ P

axiom excluded_middle: ∀ P : Prop, P ∨ ¬ P

We will return to proof by contradiction
later. For now, we explore some important
consequences of the logic we've introduced.
-/


/-
** Axiom of Excluded Middle : Classical **
-/

/-
In constructive logic, a proof of ¬ P is 
a proof of P → false, which we interpret
as a proof that there can be no proof of P. 
A proof of ¬ ¬ P is thus a proof that there
is no proof of ¬ P. In a constructive logic,
however, knowing that there no proof of ¬ P 
is not the same as having a proof of P. In
symbolic terms, from the assumption that
(P → false) → false (in one view a proof
that there can be no program that converts
proofs of P into proofs of false), you can't 
derive a proof of P. 
-/
axiom excluded_middle : ∀ P, P ∨ ¬ P

axiom exluded_middle' (P : Prop) : P ∨ ¬ P


/-
 ** DOUBLE NEGATION ELIMINATION **
-/

/-
What the axiom of the excluded middle
let's you assume is that there are only
two possibilities: either P or ¬ P, so 
¬ ¬ P, not being ¬ P, can only be P, so
¬ ¬ P is P.
-/

theorem double_neg_elim: ∀ P, ¬ ¬ P → P := 
begin
assume P : Prop,
assume pfNotNotP : ¬ ¬ P,
cases excluded_middle P,
show P, from h,
have f: false := pfNotNotP h,
exact false.elim f
end

/-
 ** PROOF BY CONTRADICTION **
-/

/-
We thus have the fundamental classical
logical "strategy" of proof by contradiction.
Read the proposition. If assuming ¬ P leads
to a contradiction, then P must be true. 
The reliance on double elimination is clear. 
The term ¬ P → false is the same as ¬ ¬ P. 

The natural reasoning is like this: if ¬
P leads to a contraction then it must be
true that ¬ P is not true, i.e., ¬ ¬ P,
But this, by classical double negation 
elimination, implies P, so P must be true.

This is negation elimination in the sense
that one starts with an assumption of ¬ P
and concludes with P. Proof by contradiction
is a means of proving P.
-/
theorem proof_by_contradiction : ∀ P : Prop,
    (¬ P → false) → P := 
        double_neg_elim

/-
The standard method for introducing
the law of the excluded middle, so as
to enable classical reasoning, in Lean,
is to use the "open classical" command
to make various classical axioms and
derived theorems available for use.
-/
open classical 


theorem proof_by_contra_1 { P Q : Prop } (pfNotPImpQNotQ: ¬ P → (Q ∧ ¬ Q)) : P :=
  by_contradiction 
    (
        -- assume ¬ P 
        assume h : ¬ P,
        -- derive a contradiction, Q ∧ ¬ Q
        have qnq : Q ∧ ¬ Q := pfNotPImpQNotQ h,
        -- from that derive false
        show false, 
        from no_contra' qnq
        -- thus derive that ¬ ¬ P,
        -- and by excluded middle, P 
    )

/-
Remember: To use proof by contradiction 
we have to use the axiom (or the so-called 
"law") of the excluded middle. Clearly it's
optional as a law.
-/



/-
PROOF BY CONTRAPOSITIVE.
-/

theorem contrapositive: 
    ∀ P Q : Prop, (¬ Q → ¬ P) → (P → Q) :=
    begin
        assume P Q: Prop,
        assume nqnp: (¬ Q → ¬ P),
        assume p : P,
        have nqf : ¬ Q → false :=
          λ nq : ¬ Q, 
            no_contra' (and.intro p (nqnp nq)),
        have nnq : ¬ ¬ Q := nqf,
        show Q,
        from double_neg_elim Q nnq
    end


/-
EXERCISE: Does it appear that one needs 
to use proof by contradiction (and thus
classical, non-constructive, reasoning) 
to prove that the square root of two is 
irrational?
-/