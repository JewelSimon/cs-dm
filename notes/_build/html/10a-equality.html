
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>PROOFS OF EQUALITY &#8212; Discrete Mathematics for Software Professionals 1 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="10. Natural Deduction" href="10-natural-deduction.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="10-natural-deduction.html" title="10. Natural Deduction"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Discrete Mathematics for Software Professionals 1 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="proofs-of-equality">
<h1>PROOFS OF EQUALITY<a class="headerlink" href="#proofs-of-equality" title="Permalink to this headline">¶</a></h1>
<p>An expression, v1=v2, is a proposition that asserts the equality of
the terms v1 and v2.  The terms are considered equal if and only if
one can produce a proof of v1=v2. There is an inference rule defined
in Lean that can produce such a proof whenever v1 and v2 are exactly
the same terms, such as in 0=0.  This rule can also produce a proof
whenever v1 and v2 reduce (evaluate) to identical terms. So we can
also produce a proof of 0+0=0, for example, because 0+0 reduces to 0,
and then you have identical terms on each side of the =. This notion
of equality is called “definitional equality”. As you’d expect, it’s a
binary, reflexive, symmetric, and transitive relation on terms. It is
also polymorphic, and so can be used for any two terms of the same
type, A, no matter what A is. The Lean inference rule that produces
proofs of definitional equality is just rfl.</p>
<p>Here (following) are several terms that are definitionally equal even
though they’re not identical. rfl is happy to build proofs for
them. The second example illustrates that terms that look pretty
different can still be definitionally equal. On the left we have a
nat/string pair. The .1 after the pair is the operator that extracts
the first element of the pair, here term 1-1. This term then reduces
to 0. The terms on either side of the = thus reduce to the same term,
0, which allows rfl to complete its work and return a value that is
accepted as being of the right type, i.e., as a proof of equality.</p>
<blockquote>
<div>theorem t0 : 1 - 1 = 5 - 5 := rfl
theorem t1 : (1-1, “fidge”).1 = 0 := rfl</div></blockquote>
<p>What you are seeing here is a strategy of proving propositions that
assert equalities in two steps: first simplify (evaluate) the
expressions on either side of the =, and then certify a proof of
equality if and only if the resulting terms are identical.  Whether
you are using a proof assistant tool such as Lean or just doing
paper-and-pencil mathematics, this is a fundamental strategy for
proving propositions of a certain kind, namely propositions that
assert equalities.</p>
<div class="section" id="propositions-are-types-proofs-are-values">
<h2>PROPOSITIONS ARE TYPES; PROOFS ARE VALUES<a class="headerlink" href="#propositions-are-types-proofs-are-values" title="Permalink to this headline">¶</a></h2>
<p>So what about proofs? They crazy idea that Lean and similar systems
are built on is that propositions can themselves be viewed as types,
and proofs as values of these types! In this analogy, a proof is a
value of a type, namely of the proposition that it proves, viewed as a
type. So just as 1 is a value of type nat, and nat in turn is a value
of type, Type, so a proof of 0=0 is a value of type 0=0! The
proposition is the type. The proof, if there is one, is a value of
such a type, and its type is Prop. To see this more clearly, we need
to build some proofs/values.</p>
<p>Here (following this comment) is a new definition, of the variable,
zeqz. But whereas before we defined x to be of the type, nat, with
value 1, now we define zeqz to be of the type, 0=0, with a value given
by that strange terms, “rfl.”</p>
<p>We’re using the proposition, 0=0, as a type! To this variable we then
assign a value, which we will understand to be a proof. Proof values
are built by what we can view as inference rules. The inference rule,
rfl, builds a proof that anything is equal to itself, in this case
that 0=0.  -/ def zeqz: 0 = 0 := rfl</p>
<p>The rfl widget, whatever it is, works for any type, not just nat.</p>
<blockquote>
<div>def heqh: “hello” = “hello” := rfl</div></blockquote>
<p>The proof is produced the rfl inference rule.  It is a “proof
constructor” (that is what an inference rule is, after all), is
polymorphic, uses type inference, takes a single argument, a, and
yields a proof of a = a.</p>
<p>The value in this case is 0 and the type is nat. What the rule says
more formally is that, without any premises you can always conclude
that for any type, A, and for any value, a, of that type, there is a
proof of a = a.</p>
<p>For example, if you need a proof of 0=0, you use this rule to build
it. The rule infers the type to be nat and the value, a, to be 0. The
result is a proof of 0 = 0. The value of zeqz in this case is thus a
<em>proof</em>, of its type, i.e., of the proposition, 0 = 0. Check the type
of zeqz. Its type is the proposition that</p>
<blockquote>
<div>#check zeqz</div></blockquote>
<p>It helps to draw a picture. Draw a picture that includes “nodes” for
all of the values we’ve used or defined so far, with arrows depicting
the “hasType” relation. There are nodes for 1, x, zeqz, nat, Prop,
Type, Type 1, Type 2, etc. KS: DRAW THE GRAPHIC</p>
<p>When we’re building values that are proofs of propositions, we
generally use the keyword, “theorem”, instead of “def”. They mean
exactly the same thing to Lean, but they communicate different
intentions to human readers. We add a tick mark to the name of the
theorem here only to avoid giving multiple definitions of the same
name, which is an error in Lean.</p>
<blockquote>
<div>theorem zeqz’: 0 = 0 := rfl</div></blockquote>
<p>We could even have defined x := 1 as a theorem.</p>
<blockquote>
<div>theorem x’‘: nat := 1</div></blockquote>
<p>While this means exactly the same thing as our original definition of
x, it gives us an entirely new view: a value is a proof of its type. 1
is thus a proof of the type nat. Our ability to provide any value for
a type gives us a proof of that type. The type checker in Lean ensures
that we never assign a value to a variable that is not of its
type. Thus it ensures that we never accept a proof that is not a valid
proof of its type/proposition.</p>
<div class="section" id="proofs-based-on-properties-of-equality">
<h3>Proofs Based on Properties of Equality<a class="headerlink" href="#proofs-based-on-properties-of-equality" title="Permalink to this headline">¶</a></h3>
<p>There are analogous strategies for dealing with other situations
involving equalities.  For example, if we have proofs of a = b and b =
c and we need a proof of a = c, then we would use an inference rule
that depends not on the reflexive property of equality but on that
fact that it is transitive: if a = b and b = c then a = c. Similarly,
there is a rule that reflects the symmetric property of equality:
given a proof of a = b, it builds and returns a proof of b = a. We do
not get into the details at this time.</p>
<div class="section" id="by-the-reflexive-property-of-equality">
<h4>By The Reflexive Property of Equality<a class="headerlink" href="#by-the-reflexive-property-of-equality" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><dl class="docutils">
<dt>theorem byRefl: ∀ α <span class="classifier-delimiter">:</span> <span class="classifier">Type, ∀ a</span> <span class="classifier-delimiter">:</span> <span class="classifier">α, a = a</span></dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">= λ (α:</th><td class="field-body">Type) (a: α), eq.refl a</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</div></blockquote>
<p>An English-language proof of p = p would read, “… p = p is true by
the reflexive property of equality.”  Remember: “rfl” is just a
shorthand for “eq.refl a”, where “a” is the value on the left of the
equals sign.</p>
</div>
<div class="section" id="by-the-symmetric-property-of-equality">
<h4>By the Symmetric Property of Equality<a class="headerlink" href="#by-the-symmetric-property-of-equality" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><dl class="docutils">
<dt>theorem bySymm: ∀ α <span class="classifier-delimiter">:</span> <span class="classifier">Type, ∀ p q: α, p = q → q = p</span></dt>
<dd><p class="first">/-
eq.symm applied to a proof of
p=q constructs a proof of q=p
-/
:= λ (α: Type) (p q: α) (pfpq: p = q),</p>
<blockquote class="last">
<div>eq.symm pfpq</div></blockquote>
</dd>
</dl>
<p>#check 1 = 2</p>
</div></blockquote>
</div>
<div class="section" id="by-the-transitive-property-of-equality">
<h4>By the Transitive Property of Equality<a class="headerlink" href="#by-the-transitive-property-of-equality" title="Permalink to this headline">¶</a></h4>
<p>The transitive property of equality
provides a corresponding inference
rule, p=q, q=r ⊢ p=r. In Lean this
rule is called eq.trans. We give an
example its use in proving a theorem
that simply asserts that equality
has the transitiveity property.</p>
<blockquote>
<div><dl class="docutils">
<dt>theorem byTrans:</dt>
<dd><dl class="first docutils">
<dt>∀ α: Type,</dt>
<dd><dl class="first last docutils">
<dt>∀ p q r: α,</dt>
<dd>p = q → q = r → p = r :=</dd>
</dl>
</dd>
</dl>
<p class="last">λ α p q r pfpq pfqr, eq.trans pfpq pfqr</p>
</dd>
</dl>
</div></blockquote>
<p>In ordinary English we’d say “if p=q and q=r then p=r. We could write
the theorem using and; we’d just have to access the proofs within the
pair constituting the proof of the conjunction.”</p>
<blockquote>
<div><dl class="docutils">
<dt>theorem byTrans’:</dt>
<dd><dl class="first docutils">
<dt>∀ α: Type,</dt>
<dd><dl class="first last docutils">
<dt>∀ p q r: α,</dt>
<dd>p = q ∧ q = r → p = r</dd>
</dl>
</dd>
</dl>
<p>/-
Applying eq.trans to a proof of p=q and
a proof of p=q and a proof of q=r yields
a proof of p=r. Here we have to extract
the proofs of p=q and q=r from the proof
of (p=q ∧ q=r).
-/
:=  λ α p q r conj,</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>eq.trans</dt>
<dd>(and.elim_left conj)
(and.elim_right conj)</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="optional-substitutability-of-equals">
<h4>Optional: Substitutability of Equals<a class="headerlink" href="#optional-substitutability-of-equals" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><dl class="docutils">
<dt>theorem substutabilityOfEquals:</dt>
<dd><dl class="first last docutils">
<dt>∀ α: Type, ∀ P: α → Prop, ∀ a1 a2: α,</dt>
<dd><p class="first">a1 = a2 → P a1 → P a2 :=
/-
If a1 equals a2, then if the predicate
(a proposition with a parameter), P, is
true of a1, then P is also true of a2.
-/</p>
<blockquote class="last">
<div>λ α P a1 a2 eql, eq.subst eql</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p>/- An exercise: Example of an Exam Question -/
theorem eq_quiz: ∀ (α : Type) (p q r s: α),</p>
<blockquote>
<div><dl class="docutils">
<dt>p = q → (p = q → r = s) → q = r → p = s :=</dt>
<dd><dl class="first last docutils">
<dt>λ α p q r s pfpq pfpqrs pfqr,</dt>
<dd><dl class="first last docutils">
<dt>eq.trans</dt>
<dd><dl class="first docutils">
<dt>(eq.trans</dt>
<dd>pfpq
pfqr)</dd>
</dl>
<p class="last">(pfpqrs pfpq)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>#check eq_quiz</p>
</div></blockquote>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="10-natural-deduction.html"
                        title="previous chapter">10. Natural Deduction</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="10-natural-deduction.html" title="10. Natural Deduction"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Discrete Mathematics for Software Professionals 1 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright .
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.5.
    </div>
  </body>
</html>