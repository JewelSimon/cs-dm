There are two different ways to be precise about what this
means. The first is as a function from *pairs* (2-tuples) of 
boolean argument values to boolean results. Adding parenthesis 
makes this clear.

{ ((T, T), T), ((T, F), F), ((F, T), F), ((F, F), F) }

The type of this function is (boolean, boolean) -> boolean.

The second possibility is that we have a function from boolean 
values to pairs of boolean values. Here's the set of tuples for
this function.

{ (T, (T, T)), (T, (F, F)), (F, (T, F)), (F, (F, F)) }

The type of this function is boolean -> 


====

/-
It is important when reading and writing mathemtical logic (and code)
to be very clear about the types of the values that are being discussed or
manipulated. We already have strong intutions for many important types. They
include the booleans, the natural numbers (the non-negative integers), the
integers, the rationals, the reals, complex numbers, and also more complex
types such as lists of values of some underlying type, e.g., list of natural
number, list of boolean, list of rational, etc.

Now we are at a point where it often pays to be much more precise about 
types and values. To this end, we introduce the concept of inductive type
definitions. An inductive type definition precisely defines a set of values
(all and the only values of the type) by giving a list of "constructors", or
ways of building values of the given type. The simplest kind of constructor
is just a "constant" -- simply the name of a value of the type in question.

In this chapter, we make this idea precise, and then build on it, by giving
an inductive definition of the type of boolean values. From you earlier work
in computer science, you already know that there are just two values of this
type, in English usually called true and false, sometimes written as 1 and 0, 
respectively, and that in this chapter we will write as T and F.

Here then is an inductive definition (in the syntax of Lean language) of a
type, that we will call "boolean", that specifies T and F as the elements
of the set of values of this type. We specify two constructors: one called 
T, a value that will henceforth be taken to be of type boolean, and one 
called F, now taken to be of type boolean. The notation "T: boolean" is what
we call a type judgment, and it asserts that T is a value of type boolean.

The set of values of type boolean thus includes T and F, and it is in the
nature of inductive definitions that the *only* values of a given type are
those that can be constructed using the available constructors. The set of
values specified by the following inductive type definition is thus {T, F}.

We have written this set using "display notation", where we list the
elements of the set separated by commas and enclosed within curly braces. 
-/

/-
The observant reader will see another type judgment in this expression:
we are specifying boolean to be a value of type, "Type". "Type" is the
type of values that are themselves types in Lean!
-/

====

/-
EXERCISE: What happens if the proofs you pass 
to and.intro aren't quite right? For example, 
try to give p as the value for both arguments. 
Does the resulting proof "type check"? Read
and explain the resulting error message.
-/

/-
EXERCISE: Formalize and prove the proposition
that 2 = 2 ∧ "Hi" = "Hi". Call the resulting
proof teqt_and_heqh.

/- ** Formal Systems ** -/
/-
A mathematical, or formal, system starts with a set 
of inference rules including axioms (with the condition 
that this starting point not be self-contradictory; so, 
for example, you would never want 0 = 1 as an axiom). 
It extends to include the typically infinite set of 
all of theorems that can be possibly "proved" by any
number of applications of available inference rules 
to already available truth judgments (or equivalently
to proofs, which in Lean are taken to be tantamount
to truth judgments).  
-/

/-
EXERCISE: What are some other theorems that you could
prove using only the concepts we've discussed so far?
Formulate and prove several new theorems. Note that 
Lean has a Boolean type, called bool, with the values
tt and ff (short for Boolean true and Boolean false).
Prove at least one theorem involving Boolean values.
-/

/- ** What mathematicians and some computer scientists do -/

/-
Working mathematicians and computer scientists don't sit
around all day mechanically generating theorems by applying
inference rules to already proved theorems to come up with
new theorems. That would be like typing randomly and hoping
to produce a new Shakespeare-quality play. 

Rather, mathematicians and computer scientists, come up
with propositions that they believe, and hope, are true
(e.g., a proposition that asserts that some program gives
the right answer for any possible combination of inputs);
and they then have the task of producing proofs to show
that such propositions are true.

We call this the problem of "proving" that a proposition
is true. If there is already a truth judgment for (proof 
of) the given proposition, it's easy: you just hand over
the existing proof. If there are proofs to which an
inference rule can be applied directly to produce a
proof for the given proposition, then you just apply the
inference rule to those proofs and you hand over the new
proof that results. In the typical case, you won't have
proofs of propositions that you need as inputs to the
inference rule that you'll ultimately want to generate
the desired proof, so you need to go off and produce
proofs of those intermediate propositions first. In this 
way the task of producing the desired proof is broken
down into one or more smaller problems of producing the
proofs that are needed to feed the inference rule that
will be used to produce the final proof. 

Mathematicians typically label the proposition that is
ultimately to be proved as a theorem (once there really
is a proof), and the smaller propositions to be proved
as lemmas. In Lean you can use theorem and lemma (and
a few other keywords, such as def) interchangeably.

Such a process is said to be "recursive". Axioms give
you starting points. You then apply inference rules to
produces proofs of larger and larger lemmas. Finally 
you apply some inference rule to proofs of key lemmas
to produce a proof of the desired theorem. 

The chain of "derivations" that thus results is what
logicians and mathematicians sometimes call a proof tree.
Such trees can be written using inference rule notation.

Here's the entire proof tree for 0 = 0 ∧ 1 = 1. 
